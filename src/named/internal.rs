use core::marker::PhantomData;

/**
 A marker trait that is used to represent unique type in Rust.
 `mononym` guarantees that any two `impl Name` generated by
 the library are always considered distinct types by Rust.

 This is mainly used as a type parameter inside types such as
 [`Seed`]. For example, the type `impl Seed`
 is used to represent a unique seed type with a fresh type
 `impl Name` being its name.
*/
pub trait Name: Send + Sync + Sealed {}

/**
 A marker trait that is used to mark a type-level name being bound to
 a Rust value of the given type `T`. This helps ensure that functions
 that are generic over type-level names are "well-typed", with
 each name "having" their own type through `HasType`.

 With `Name` being a supertrait of `HasType`, this means that any
 name type can have their "type" erased by downcasting the type from
 `impl HasType<T>` to `impl Name`.

 This trait is used as a type parameter inside [`Named`], so that the
 type `Named<impl HasType<T>, T>` also attaches the type information
 to the type-level name associated with the named value.
*/
pub trait HasType<T>: Name {}

/**
 Represents a named value with a unique type-level name. `monoym`
 guarantees that there can never be two Rust values of the same
 type `Named<N, T>`. With that, the name type `N` can be used to
 uniquely identify the underlying value at the type level.

 To ensure that functions that are generic over names are well-typed
 `Named` also requires the name type `N` to satisfy the trait bound
 [`HasType<T>`]. Although this may introduce more boilerplate,
 it also helps programmers to always annotate the type of names
 when defining new generic functions.
*/
pub struct Named<N: HasType<T>, T>(T, PhantomData<N>);

/**
 This trait is not exported so that the Name trait
 becomes a [_sealed trait_](https://rust-lang.github.io/api-guidelines/future-proofing.html)
 which user cannot provide custom implementation to.
*/
pub trait Sealed {}

pub trait Seed: Sealed + Send + 'static
{
  type Name<T>: HasType<T>;

  type Next1: Seed;

  type Next2: Seed;

  fn replicate(self) -> (Self::Next1, Self::Next2);

  fn new_named<T>(
    self,
    value: T,
  ) -> Named<Self::Name<T>, T>;
}

impl<'a> Life<'a>
{
  /**
   Turns a unique lifetime proxy to an existential [`Seed`].
   Since all `Life<'a>` must be unique via [`with_seed`],
   the returned `impl Seed` is also always unique.

   The existential associated types `Next1` and Next2` are
   also treated as different types by Rust, even though they
   all have the same underlying concrete type. In other words,
   the following test must fail:

   ```rust,compile_fail
   # use mononym::*;
   fn same<T>(_: T, _: T) {}
   fn same_next<'a>(life: Life<'a>) {
     let (seed1, seed2) = life.into_seed().replicate();
     same(seed1, seed2);
   }
   ```
  */
  pub fn into_seed(self) -> impl Seed
  {
    struct SomeName;
    struct SomeSeed;

    impl Sealed for SomeName {}
    impl Name for SomeName {}
    impl<T> HasType<T> for SomeName {}

    impl Sealed for SomeSeed {}
    impl Seed for SomeSeed
    {
      type Name<T> = SomeName;
      type Next1 = SomeSeed;
      type Next2 = SomeSeed;

      fn replicate<'a>(self) -> (Self::Next1, Self::Next2)
      {
        (SomeSeed, SomeSeed)
      }

      fn new_named<T>(
        self,
        value: T,
      ) -> Named<Self::Name<T>, T>
      {
        Named(value, PhantomData)
      }
    }

    SomeSeed
  }
}

/**
 Turns a lifetime `'name` into a unique type `Life<'name>`
 with an invariant phantom lifetime. `Life` implements [`Name`]
 so that it can be turned into a unique `impl Name`.

 The body [`PhantomData`] has a phantom type `*mut &'name ()`
 to ensure that overlapping lifetimes such as
 `'name1: 'name2` are treated as distinct types and cannot be
 coerced into one another, unless they are exactly the same.

 For example, the following test should fail:

 ```rust,compile_fail
 # use mononym::*;
 fn same<T>(_: T, _: T) {}
 fn same_life<'name1, 'name2: 'name1>(
   life1: Life<'name1>,
   life2: Life<'name2>
 ) {
   same(life1, life2); // error
 }
 ```
*/
pub struct Life<'name>(PhantomData<*mut &'name ()>);

/**
 Provides the continuation closure with a unique [`Seed`] with a unique lifetime
 `'name` and a unique name [`Life<'name>`](Life).

 This is achieved using
 [higher-ranked trait bounds](https://doc.rust-lang.org/nomicon/hrtb.html)
 by requiring the continuation closure to work for all lifetime `'name`.

 It is safe to have multiple nested calls to `with_seed`, as each call
 will generate new seed type with a unique `'name` lifetime. For example,
 the following code should fail to compile:

 ```rust,compile_fail
 # use mononym::*;
 fn same<T>(_: T, _: T) {}
 with_seed(|seed1| {
   with_seed(|seed2| {
     same(seed1, seed2); // error
     same(seed1.new_named(1), seed2.new_named(1)); // error
   });
 });
 ```

 The function allows the continuation closure to return any concrete type
 `R`, provided that the return type `R` does not depend on the provided
 `Seed` type in some way. This means that types such as [`Name`],
 [`Named`], and [`Seed`] cannot be used as a return value, as Rust
 consider that as allowing the lifetime `'name` to escape. For example,
 the following code should fail to compile:

 ```rust,compile_fail
 # use mononym::*;
 let res = with_seed(|seed| { seed.new_named(42).into_value() }); // ok
 let res = with_seed(|seed| { seed }); // error
 let res = with_seed(|seed| { seed.new_name() }); // error
 let res = with_seed(|seed| { seed.new_named(42) }); // error
 ```
*/
pub fn with_seed<R>(cont: impl for<'name> FnOnce(Life<'name>) -> R) -> R
{
  cont(Life(PhantomData))
}

impl<N: HasType<T>, T> Named<N, T>
{
  /**
   Get a reference to the underlying value of the named value.
   `mononym` does not provide access to mutable reference to
   the underlying value, as mutation may invalidate the proofs
   of pre-conditions constructed from the original value.

   When using `Named`, it is up to the user to ensure that there
   is no accidental
   [interior mutability](https://doc.rust-lang.org/reference/interior-mutability.html)
   provided by the value type `T`. Otherwise, user must take
   into consideration of the possibility of interior mutability
   and ensure that the invariants assumed by the proofs defined
   cannot be violated.
  */
  pub fn value(&self) -> &T
  {
    &self.0
  }

  /**
   Consume the named value and turn it back into the underlying value.
   After this, the underlying value is no longer associated with the
   type-level name, and can be safely mutated.

   Even though the named value is destroyed, the type-level name
   can still continue to present in other places such as proof objects.
   This can be useful for functions that only require proofs about
   a value, without requiring access to the value itself.
  */
  pub fn into_value(self) -> T
  {
    self.0
  }
}
